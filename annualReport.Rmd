---
title: "Annual Report"
author: "Sam Graf"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE, echo = FALSE}
library(tidyverse) 
library(lubridate)
library(DT)
library(plotly)
library(shiny) #for the isTruthy() function in getSequences
library(sf)
library(gganimate)
library(basemaps)

options(dplyr.summarise.inform = FALSE)
if(!exists("combinedData_df_list")){
  combinedData_df_list <- readRDS("data/flatFilesforApp/combinedData_df_list.rds")
}
if(!exists("indiv_datasets_list")){
  indiv_datasets_list <- readRDS("data/flatFilesforApp/indiv_datasets_list.rds")
}
if(!exists("Enc_release_data")){
  Enc_release_data <- readRDS("data/flatFilesforApp/Enc_release_data.rds")
}
if(!exists("encounterMARKStates")){
  encounterMARKStates <- readRDS("data/flatFilesforApp/encounterMARKStates.rds")
}
if(!exists("movements_list")){
  movements_list <- readRDS("data/flatFilesforApp/movements_list.rds")
}
if(!exists("unknown_tags")){
  unknown_tags <- readRDS("data/flatFilesforApp/unknown_tags.rds")
}

if(!exists("avianPredationList")){
  avianPredationList <- readRDS("data/flatFilesforApp/possibleAvianPredationDFs.rds")
}

if(!exists("wgfpMetadata")){
  wgfpMetadata <- readRDS("data/flatFilesforApp/wgfpMetadata.rds")
}

if(!exists("metaDataVariableNames")){
  metaDataVariableNames <- readRDS("data/flatFilesforApp/metaDataVariableNames.rds")
}

if(!exists("PTData")){
  PTData <- readRDS("data/flatFilesforApp/PTData.rds")
}

if(!exists("USGSData")){
  USGSData <- readRDS("data/flatFilesforApp/USGSData.rds")
}

if(!exists("SiteVisitData")){
  SiteVisitData <- readRDS("data/flatFilesforApp/SiteVisitData.rds")
}

neededFunctions <- c("Animation_function.R", "getSequences.R")

for (i in neededFunctions) {
  source(paste0("./functions/",i))
}

for (i in list.files("./miscR/")) {
  if (grepl(".R", i)) {
    source(paste0("./miscR/",i))
  }
}

rainbow_trout_colors <- c("#8B8000", "#008080", "#FF69B4", "#FF4500", "#6A5ACD","#32CD32", "#20B2AA",
                          "#FF1C55", "#4682B4", "#556B2F", "#DC143C", "#B22222", "#7FFF00", "#8A2BE2", "#00CED1")
#currently "Changed Rivers", "Downstream Movement" "Initial Release", "No Movement", "Upstream Movement" (5/17/24)
#note: these are a little diffeerent than what we see in the map because the map/marker color optoins are very limited. 
movementColorsValues <- c("purple", "#eb0e2b", "#FF8C00", "gray", "#22bd74") #, "#66FF00"
# currently "BRK" "LOC" "MERG" "MTS" "RBT" "RXN" "TGM" (5/17/24)
speciesColors <- c("#FFD700", "#654321", "#4F7942", "#FF7F50", "#1E90FF", "#008080", "#DAA520", "#D2691E", "#9A5ECD") 

#maybe a better method for this, but pressure transducer site names are changed to the same names as Site Visit site names
#and that variable is what we use to assign colors to sites   
allSites <- metaDataVariableNames$allDetectionDistanceSiteNames
movementColors <- setNames(movementColorsValues, sort(unique(movements_list$Movements_df$movement_only)))
siteColors <- setNames(rainbow_trout_colors[0:length(allSites)], allSites)
speciesColors <- setNames(speciesColors[0:length(unique(indiv_datasets_list$releasedata$Species))], sort(unique(indiv_datasets_list$releasedata$Species)))
 
allColors <- c(movementColors, siteColors, speciesColors)

biomarkAntennas <- str_subset(wgfpMetadata$AntennaMetadata$SiteName, "Biomark")
biomarkAntennasFrontends <- wgfpMetadata$AntennaMetadata[wgfpMetadata$AntennaMetadata$SiteName %in% biomarkAntennas, "FrontendSiteCode"]

StationaryAntennas <- str_subset(wgfpMetadata$AntennaMetadata$SiteName, "Stationary")
StationaryAntennasFrontends <- wgfpMetadata$AntennaMetadata[wgfpMetadata$AntennaMetadata$SiteName %in% StationaryAntennas, "FrontendSiteCode"]
mobileCodes <- wgfpMetadata$AntennaMetadata[wgfpMetadata$AntennaMetadata$SiteName == "Mobile Run", "FrontendSiteCode"]

```

## Tagging Summary
### All Data Excludes TGM

```{r, echo = FALSE, include=TRUE, warning=FALSE,message=FALSE,error=FALSE}
ReleaseData <- indiv_datasets_list$releasedata %>%
  mutate(Date = as.Date(Date)) %>%
  filter(!Species %in% c("TGM"))
Recaptures <- indiv_datasets_list$recapdata %>%
  mutate(Date = as.Date(Date))

releaseRecaps <- Recaptures %>%
  rename(ReleaseSite = RecaptureSite) %>%
  bind_rows(ReleaseData) %>%
  rename(Site = ReleaseSite) %>%
  count(Event, Year = year(Date), Species)

datatable(releaseRecaps, 
          caption = "Release/Recapture Summaries, No TGM",
  options = list(
    pageLength = 10,
    autoWidth = TRUE
  ),
  filter = list(
  position = 'top', clear = FALSE
),
  rownames = FALSE
  )
# number of fish tagged 
ReleaseData %>%
          ggplot(aes(x = Length, fill = Species) ) +
          geom_histogram(binwidth = 20)+
          theme_classic() +
          labs(title = "Released Fish by Length", caption = "Binwidth = 20mm") +
          scale_fill_manual(values = allColors) +
          facet_wrap(~year(Date))
# percentage fish released, how many were TLNT, vs recap vs straigght release, by species  
# table 
ReleaseCounts <- ReleaseData %>%
  count(Year = year(Date), ReleaseSite, Species, Event) 

datatable(ReleaseCounts, 
          caption = "Release Summaries",
  options = list(
    pageLength = 10,
    autoWidth = TRUE
  ),
  filter = list(
  position = 'top', clear = FALSE
),
  rownames = FALSE
  )
# number recaptured, how many were TLNT (Recapped and Release)
RecaptureCounts <- Recaptures %>%
  count(Year = year(Date), RecaptureSite, Species) 

datatable(RecaptureCounts, 
          caption = "Recapture Summaries",
  options = list(
    pageLength = 10,
    autoWidth = TRUE
  ),
  filter = list(
  position = 'top', clear = FALSE
),
  rownames = FALSE
  ) #%>%
  #formatPercentage(c("DS Percentage"), 2)
#Length and Weight Range
#range(ReleaseData$)
LWRanges <- ReleaseData %>%
  group_by(Year = year(Date), Species) %>%
  summarise(`Minimum Length (mm)` = round(min(Length, na.rm = T), 2), 
            `Maximum Length (mm)` = round(max(Length, na.rm = T), 2),
            `Average Length (mm)` = round(mean(Length, na.rm = T), 2),
            `Minimum Weight (g)` = round(min(Weight, na.rm = T), 2), 
            `Maximum Weight (g)` = round(max(Weight, na.rm = T), 2),
            `Average Weight (g)` = round(mean(Weight, na.rm = T), 2))

datatable(LWRanges, 
          caption = "Length and Weight Summaries",
  options = list(
    pageLength = 10,
    autoWidth = TRUE
  ),
  filter = list(
  position = 'top', clear = FALSE
),
  rownames = FALSE
  )

```
## Movement Summary

```{r, include=TRUE, echo=FALSE}
movementsData <- movements_list$Movements_df %>%
  filter(!Species %in% c("TGM"), 
         !det_type %in% c("Mobile Run")
         )
# how many swam through channel?
#these are all based off states created in createMARKhistoriesFunction()
Enc_release_data1 <- Enc_release_data %>%
  mutate(`Length Bin` = cut(
    Length,
    breaks = c(0, 100, 200, 300, 400, 500, Inf),
    labels = c("0-100", "100-200", "200-300", "300-400", "400-500", "500+"),
    right = FALSE
))
#can use the wide summaries definition: basically how many fish were detected in state "D" (connectivity channel)
# or we could use the sequences definition and make US and DS sequences of WG2/1/HP to CF with CRCC antennas in the middle
#fish that have been detected in the channel (aka state D)
#this includes fish that were shocked and released in the channel

usedChannel <-  Enc_release_data1 %>%
  filter(channelSummary == "Used Connectivity Channel") 
#went below the dam through channel
dsChannelUsage <- Enc_release_data1 %>%
  filter(went_below_dam_throughChannel == TRUE)
#upstream channel usage
usChannelUsage <- Enc_release_data1 %>%
  filter(went_above_dam_throughChannel == TRUE)

#make these into tables by species and size
usedChannelSummarizedTotal <- usedChannel %>%
  summarise(`Total Fish Detected In Channel` = n())
dsChannelUsageSummarizedTotal <- dsChannelUsage %>%
  summarise(`Total Fish Swam Downstream Through Channel` = n())
usChannelUsageSummarizedTotal <- usChannelUsage %>%
  summarise(`Total Fish Swam Upstream Through Channel` = n())

totalFishChannelTable <- bind_cols(list(usedChannelSummarizedTotal, dsChannelUsageSummarizedTotal, usChannelUsageSummarizedTotal))
datatable(
    totalFishChannelTable,
    caption = "CRCC Usage, Total Fish", 
    rownames = FALSE,
    selection = "single",
    options = list(
      stateSave = TRUE,
      pageLength = 10,
      info = TRUE
    )
  )

#by species 
#make these into tables by species and size
usedChannelSummarizedSpecies <- usedChannel %>%
  group_by(Species) %>%
  summarise(`Total Fish Detected In Channel` = n())
dsChannelUsageSummarizedSpecies <- dsChannelUsage %>%
  group_by(Species) %>%
  summarise(`Total Fish Swam Downstream Through Channel` = n())
usChannelUsageSummarizedSpecies <- usChannelUsage %>%
  group_by(Species) %>%
  summarise(`Total Fish Swam Upstream Through Channel` = n())

#missing rows, so do a full_join instead of bindig cols

speciesChannelTable <- usedChannelSummarizedSpecies %>%
  full_join(dsChannelUsageSummarizedSpecies, by = "Species") %>%
  full_join(usChannelUsageSummarizedSpecies, by = "Species")

speciesChannelTable[is.na(speciesChannelTable)] <- 0

datatable(
    speciesChannelTable,
    caption = "CRCC Usage by Species", 
    rownames = FALSE,
    selection = "single",
    options = list(
      stateSave = TRUE,
      pageLength = 10,
      info = TRUE
    )
  )
#by length 
usedChannelSummarizedLength <- usedChannel %>%
  count(`Length Bin`, name = "Total Fish Detected In Channel") %>%
  arrange(`Length Bin`)
  
dsChannelUsageSummarizedLength <- dsChannelUsage %>%
  count(`Length Bin`, name = "Total Fish Swam Downstream Through Channel") %>%
  arrange(`Length Bin`)
usChannelUsageSummarizedLength <- usChannelUsage %>%
  count(`Length Bin`, name = "Total Fish Swam Upstream Through Channel") %>%
  arrange(`Length Bin`)

lengthChannelTable <- usedChannelSummarizedLength %>%
  full_join(dsChannelUsageSummarizedLength, by = "Length Bin") %>%
  full_join(usChannelUsageSummarizedLength, by = "Length Bin")

lengthChannelTable[is.na(lengthChannelTable)] <- 0

datatable(
    lengthChannelTable,
    caption = "CRCC Usage by Length", 
    rownames = FALSE,
    selection = "single",
    options = list(
      stateSave = TRUE,
      pageLength = 10,
      info = TRUE
    )
  )
#Annual Figure of Upstream vs downstream movements
seasonal_movts <- movementsData %>%
  filter(!movement_only %in% c("Initial Release")) %>%
  group_by(Month = lubridate::month(Date), Day = day(Date), movement_only) %>%
  summarise(total_events = n())

plot <- seasonal_movts %>%
            mutate(merged = (parse_date_time(paste(Month, Day), "md"))) %>%
            ggplot(aes(x = merged, y = total_events, fill = movement_only)) +
            geom_bar(stat = "identity", position = "dodge") +
            theme_classic() +
            labs(title = "Seasonal Daily Movements", x = "Day", y = "Counts",
                 caption = "Currently No download option for this data.") +
            scale_x_datetime(date_labels = "%b") +
            scale_fill_manual(values = allColors)
          
ggplotly(plot)

datatable(
    seasonal_movts,
    caption = "Releases and Mobile Runs not included", 
    rownames = FALSE,
    selection = "single",
    filter = 'top',
    options = list(
      stateSave = TRUE,
      pageLength = 10,
      info = TRUE,
      lengthMenu = list(c(10, 25, 50, 100, 200), c("10", "25", "50", "100", "200")),
      dom = 'lfrtip'
    )
  )
          
          

#movements by size/age class
movementsLength <- movementsData %>%
  mutate(`Length Bin` = cut(
    Release_Length,
    breaks = c(0, 100, 200, 300, 400, 500, Inf),
    labels = c("0-100", "100-200", "200-300", "300-400", "400-500", "500+"),
    right = FALSE
))

movementsLengths <- movementsLength %>%
  count(`Length Bin`, movement_only) %>%
  arrange(`Length Bin`, movement_only) 

movementsLengthsWide <- movementsLengths %>%
  pivot_wider(names_from = movement_only, values_from = n) %>%
  mutate(`DS Percentage` = `Downstream Movement`/(`Upstream Movement` + `Downstream Movement`))

datatable(movementsLengthsWide, 
          caption = "Movement Summary Table by Length Bins",
  options = list(
    pageLength = 10,
    autoWidth = TRUE
  ),
  filter = list(
  position = 'top', clear = FALSE
),
  rownames = FALSE
  ) %>%
  formatPercentage(c("DS Percentage"), 2)

plot <- ggplot(movementsLengths, aes(x = `Length Bin`, y = n, fill = movement_only)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    x = "Length Bin (mm)",
    y = "Count of Movements",
    fill = "Movement Type",
    title = "Distribution of Movement Types Across Length Bins"
  ) +
  theme_minimal() +
  scale_fill_manual(
    values = c(
      "Changed Rivers"        = "purple",
      "Downstream Movement"   = "#eb0e2b",
      "No Movement"           = "gray",
      "Upstream Movement"     = "#22bd74"
    )
  ) +
  #facet_wrap(~Species, ncol = 2) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

ggplotly(plot)

```

## Antenna data
```{r, include=TRUE, echo=FALSE}
# number of days the antennas were down across all antennas
antennasDown <- wgfpMetadata$MarkerTagIssues %>%
  filter(wholeAntennaDown_nofishDetections == "yes") %>%
  mutate(timeDif = difftime(IssueEndDatetime, IssueStartDatetime, units = "days")) 
##start with stationary antennas
stationaryAntennasDown <- antennasDown %>%
  #mutate(Site = trimws(Site)) %>%
  filter(Site %in% StationaryAntennasFrontends$FrontendSiteCode) %>%
  summarise(`Total Time Antennas were down` = sum(timeDif))
#c("G1", "M1", "M2", "B5", biomarkAntennasFrontends$FrontendSiteCode)
stationaryAntennaTimeGrouped <- combinedData_df_list$All_Detections %>%
  #take out mobile and ghost backpack detections and dummy tag and biomark detections (we'll get them later)
  filter(Site_Code %in% StationaryAntennasFrontends$FrontendSiteCode) %>%
  group_by(Site_Code) %>%
  summarise(`Total Duration` = difftime(max(Scan_DateTime), min(Scan_DateTime), units = "days")) %>%
  ungroup()
StationaryAntennaTimeTotal <- stationaryAntennaTimeGrouped %>%
  summarise(`Total Duration` = sum(`Total Duration`))

totalDowntimePercentage = round((as.numeric(stationaryAntennasDown$`Total Time Antennas were down`) / as.numeric(StationaryAntennaTimeTotal$`Total Duration`)) * 100, 2)

stationaryAntennaTimeSummaryMessage <- paste0("Stationary Antennas were down for ", totalDowntimePercentage, "% of the total time across all Stationary Antennas. Inidividual Antennas were down for a total of ", round(stationaryAntennasDown$`Total Time Antennas were down`, 2), " days out of a total of ", round(StationaryAntennaTimeTotal$`Total Duration`, 2), " days of total time across all Stationary Antennas.")

### biomark

#total time biomark antennas were down
biomarkAntennasDown <- antennasDown %>%
  filter(Site %in% biomarkAntennasFrontends$FrontendSiteCode) %>%
  summarise(`Total Time Antennas were down` = sum(timeDif))
#total time they were up: sum of all deployment durations
biomarkAntennaTimeTotal <- wgfpMetadata$DeploymentDurations %>%
  filter(Type == "Biomark") %>%
  summarise(`Total Duration` = sum(difftime(max(DeploymentEnd, na.rm = TRUE), min(DeploymentStart, na.rm = TRUE), units = "days")))

totalBiomarkDowntimePercentage = round((as.numeric(biomarkAntennasDown$`Total Time Antennas were down`) / as.numeric(biomarkAntennaTimeTotal$`Total Duration`)) * 100, 2)

biomarkAntennaTimeSummaryMessage <- paste0("Biomark Antennas were down for ", totalBiomarkDowntimePercentage, "% of the total time across all Biomark Antennas. Inidividual Antennas were down for a total of ", round(biomarkAntennasDown$`Total Time Antennas were down`, 2), " days out of a total of ", round(biomarkAntennaTimeTotal$`Total Duration`, 2), " days of total time across all Biomark Antennas.")

# how many fish were seen on each antenna

#this doesn't have marker tags and only contains tags in the release file
#do i want to take out ghost antenna g1? only 6 detections
All_EventsData <- combinedData_df_list$All_Events %>%
  filter(!TAG %in% c(230000999999))


# number of detections by year by antenna; 
plot <- All_EventsData %>%
                ggplot(aes(x= Date, fill = Event,
                           text = paste('Date: ', as.character(Date), '\n')
                )) +
                geom_bar(stat = "count", position = "dodge") +
                theme_classic() 

ggplotly(p = plot)

frequenciesSummarized <- All_EventsData %>%
            filter(#antennas only
                   Event %in% c(biomarkAntennasFrontends$FrontendSiteCode, StationaryAntennasFrontends$FrontendSiteCode)) %>%
            count(Event, Year = year(Date), name = "Raw Detections") %>%
  arrange(desc(Year)) %>%
  left_join(wgfpMetadata$AntennaMetadata[, c("FrontendSiteCode", "AntennaSite")], by = c("Event" = "FrontendSiteCode")) %>%
  relocate(AntennaSite, .before = Event)
          
datatable(frequenciesSummarized,
          rownames = FALSE,
          caption = c("Raw Number of Fish Detections by Antenna and Year"),
          extensions = c('Buttons'),
          #for slider filter instead of text input
          filter = 'top',
          options = list(
            pageLength = 10, info = TRUE, lengthMenu = list(c(10,25), c("10", "25")),
            dom = 'Blfrtip', #had to add 'lowercase L' letter to display the page length again #errorin list: arg 5 is empty because I had a comma after the dom argument so it thought there was gonna be another argument input
            language = list(emptyTable = "Enter inputs and press Render Table")
          ) #end of options list
)


# by type; total detections on stationary vs biomark vs mobile vs recaps
frequenciesSummarizedType <- All_EventsData %>%
  mutate(detType = case_when(Event %in% StationaryAntennasFrontends$FrontendSiteCode ~ "Stationary", 
                                 Event %in% biomarkAntennasFrontends$FrontendSiteCode ~ "Biomark",
                                 Event %in% mobileCodes$FrontendSiteCode ~ "Mobile",
                             TRUE ~ Event
                                 ))

frequenciesSummarizedType1 <- frequenciesSummarizedType %>%
  count(`Event Type` = detType, Year = year(Date), name = "Raw Detections") %>%
  arrange(desc(Year)) 

datatable(frequenciesSummarizedType1,
          rownames = FALSE,
          caption = c("Raw Number of Fish Detections by Detection Type and Year"),
          extensions = c('Buttons'),
          #for slider filter instead of text input
          filter = 'top',
          options = list(
            pageLength = 10, info = TRUE, lengthMenu = list(c(10,25), c("10", "25")),
            dom = 'Blfrtip', #had to add 'lowercase L' letter to display the page length again #errorin list: arg 5 is empty because I had a comma after the dom argument so it thought there was gonna be another argument input
            language = list(emptyTable = "Enter inputs and press Render Table")
          ) #end of options list
)

#unique detections; are we getting tags with these other methods that we don't see on stationary or other types?
stationaryTags <- frequenciesSummarizedType %>%
  filter(detType == "Stationary") %>%
  distinct(TAG)

biomarkTags <- frequenciesSummarizedType %>%
  filter(detType == "Biomark") %>%
  distinct(TAG)
mobileTags <- frequenciesSummarizedType %>%
  filter(detType == "Mobile") %>%
  distinct(TAG)

recappedTags <- frequenciesSummarizedType %>%
  filter(detType == "Recapture") %>%
  distinct(TAG)
dataToDif <- c(biomarkTags$TAG, mobileTags$TAG, recappedTags$TAG)
onlyStationaryUnique <- base::setdiff(stationaryTags$TAG, dataToDif)
numberofStationaryUniqueTags <- length(onlyStationaryUnique)

dataToDif <- c(stationaryTags$TAG, mobileTags$TAG, recappedTags$TAG)
onlyBiomarkUnique <- base::setdiff(biomarkTags$TAG, dataToDif)
numberofBiomarkUniqueTags <- length(onlyBiomarkUnique)

dataToDif <- c(stationaryTags$TAG, biomarkTags$TAG, recappedTags$TAG)
onlyMobileUnique <- base::setdiff(mobileTags$TAG, dataToDif)
numberofMobileUniqueTags <- length(onlyMobileUnique)

dataToDif <- c(stationaryTags$TAG, biomarkTags$TAG, mobileTags$TAG)
onlyRecappedUnique <- base::setdiff(recappedTags$TAG, dataToDif)
numberofRecappedUniqueTags <- length(onlyRecappedUnique)

x <- All_EventsData %>%
  filter(TAG == "230000087762") %>%
  arrange(Datetime)

uniqueDetectionsMessage <- paste0("Stationary Antennas detected ", numberofStationaryUniqueTags, " fish that were not detected by mobile, biomark, or recapture methods. Biomark Antennas detected ", numberofBiomarkUniqueTags, " fish that were not detected by mobile, stationary, or recapture methods. Mobile Antennas detected ", numberofMobileUniqueTags, " fish that were not detected by biomark, stationary, or recapture methods. There were ", numberofRecappedUniqueTags, " fish recaptured that were not detected by biomark, stationary, or recapture methods."      
                                  )

```
#### `r stationaryAntennaTimeSummaryMessage`
#### `r biomarkAntennaTimeSummaryMessage`

#### `r uniqueDetectionsMessage`

## Before and After
```{r beforeAFter, echo=FALSE, results='hide',include=TRUE, warning=FALSE,message=FALSE,error=FALSE}
#movements from HP to CF before construction of channel vs after channel
#based off  getSequences() whereas above the "used channel" stuff is based on states

##BEFORE PERIOD HP TO CF AND VICE VERSA SEQUENCES
#get sequences with Hp, wg antenas to CF before

beforeStartDate <- min(ymd_hms(wgfpMetadata$DeploymentDurations$DeploymentStart), na.rm = T)
beforeEndDate <- ymd_hms("2023-10-18 12:44:05") #first CRCC antenna online, from metadata
totalDaysBefore <- difftime(beforeEndDate, beforeStartDate, units = "days")
#exclude avian predatation
allEventsAvianExcluded <- combinedData_df_list$All_Events %>%
    dplyr::filter(!TAG %in% unique(indiv_datasets_list$avian_preddata$TagID))
beforeDataAvianPredationFiltered <- allEventsAvianExcluded %>%
  dplyr::filter(Datetime >= beforeStartDate & Datetime <= beforeEndDate) 

beforeHPCFSequences <- invisible(getSequences(beforeDataAvianPredationFiltered, c("HP", "WG1", "WG2"), "", c("CF"), c("M1", "M2")))
beforeCFHPSequences <- invisible(getSequences(beforeDataAvianPredationFiltered, c("CF"), "", c("HP", "WG1", "WG2"), c("M1", "M2")))

##AFTER PERIOD HP TO CF SEQUENCES

#some fish' totla jhouinreys are not caputred, like 230000294213. Sequnce recorded hp to cs to cu to cf on 10/12/2025, but lingered up and down the channel 10/6/2025 so that sequnece not totally captured, which is ok honestly for this method
# another way to change this woudl be to use States, as is done above in the "Used channel" kind of stuff
#idea: make sequences but with states instead of antennas for app. both good optoins
afterDataAvianPredationFiltered <- allEventsAvianExcluded %>%
  dplyr::filter(Datetime > beforeEndDate) 

totalDaysAfter <- difftime(max(afterDataAvianPredationFiltered$Date, na.rm = TRUE), min(afterDataAvianPredationFiltered$Date, na.rm = TRUE), units = "days")
#UPSTREAM
#hp to cf after channel construction, no predation
afterHPCFSequencesThroughChannel1 <- invisible(getSequences(afterDataAvianPredationFiltered, c("HP", "WG1", "WG2"), "", c("CF"), c("M1", "M2")))
#fish swam up the channel in whole entirety of study
middleAntennas <- list(c("CD", "CS"), c("CU"))
afterHPCFSequencesThroughChannel <- invisible(getSequences(allEventsAvianExcluded, c("HP", "WG1", "WG2"), middleAntennas, c("CF"), c("M1", "M2")))
#sequences through channel with any antenna in the middle
afterHPCFSequencesThroughChannel2 <- invisible(getSequences(allEventsAvianExcluded, c("HP", "WG1", "WG2"), c("CD", "CS", "CU"), c("CF"), c("M1", "M2")))
totalAfterUSSequences <- nrow(afterHPCFSequencesThroughChannel1) + nrow(afterHPCFSequencesThroughChannel) + nrow(afterHPCFSequencesThroughChannel2)

#DOWNSTREAM
middleAntennasDS <- list(c("CU"), c("CD", "CS")) 
afterHPCFSequencesDSThroughChannel <- invisible(getSequences(allEventsAvianExcluded, c("CF"), middleAntennasDS, c("HP", "WG1", "WG2"), c("M1", "M2")))
afterHPCFSequencesDSThroughChannel1 <- invisible(getSequences(afterDataAvianPredationFiltered, c("CF"), "", c("HP", "WG1", "WG2"), c("M1", "M2")))
afterHPCFSequencesDSThroughChannel2 <- invisible(getSequences(allEventsAvianExcluded, c("CF"), c("CD", "CS", "CU"), c("HP", "WG1", "WG2"), c("M1", "M2")))
totalAfterDSSequences <- nrow(afterHPCFSequencesDSThroughChannel) + nrow(afterHPCFSequencesDSThroughChannel1) + nrow(afterHPCFSequencesDSThroughChannel2)

###MESSAGES
totalBeforeSequenceMessage <- paste0("Before the Connectivity Channel was built, there were ", nrow(beforeHPCFSequences), " upstream journeys from Hitching Post Antenna or Windy Gap Biomark Antenna below the dam to Confluence Antenna by non-Avian Predated fish and ", nrow(beforeCFHPSequences), " downstream journeys from Confluence Antenna to Hitching Post Antenna or Windy Gap Biomark Antenna below the dam, over the course of ", round(totalDaysBefore, 2), " days. This equates to one upstream journey every ", round(as.numeric(totalDaysBefore)/nrow(beforeHPCFSequences), 2), " days and one downstream journey every ", round(as.numeric(totalDaysAfter)/nrow(beforeCFHPSequences), 2), " days.") 

totalAfterSequenceMessage <- paste0("Since the Connectivity Channel was built, there have been ", totalAfterUSSequences, " upstream journeys from Hitching Post Antenna or Windy Gap Biomark Antenna to Confluence Antenna by non-Avian Predated fish AFTER Channel was built and ", totalAfterDSSequences, " downstream journeys from Confluence Antenna to Hitching Post Antenna or Windy Gap Biomark Antenna below the dam, over the course of ", round(totalDaysAfter, 2), " days. This equates to one upstream journey every ", round(as.numeric(totalDaysAfter)/totalAfterUSSequences, 2), " days and one downstream journey every ", round(as.numeric(totalDaysAfter)/totalAfterDSSequences, 2), " days on average.")
###RB and HP Movements for COMPARISON
#rb to hp before
#US
rbHPBeforeUS <- invisible(getSequences(beforeDataAvianPredationFiltered, c("RB"), "", c("HP"), c("M1", "M2")))
#DS
rbHPBeforeDS <- invisible(getSequences(beforeDataAvianPredationFiltered, c("HP"), "", c("RB"), c("M1", "M2")))

#After
#US
rbHPAfterUS <- invisible(getSequences(afterDataAvianPredationFiltered, c("RB"), "", c("HP"), c("M1", "M2")))
#DS
rbHPAfterDS <- invisible(getSequences(afterDataAvianPredationFiltered, c("HP"), "", c("RB"), c("M1", "M2")))

beforeRBtoHPSequencesMessage <- paste0("In comparison, before the Connectivity Channel was built, there were ", nrow(rbHPBeforeUS), " upstream journeys from Red Barn Antenna to Hitching Post Antenna by non-Avian predated fish and ", nrow(rbHPBeforeDS), " downstream journeys from Hitching Post Antenna to Red Barn over the course of ", round(totalDaysBefore, 2), " days. This equates to one upstream journey every ", round(as.numeric(totalDaysBefore)/nrow(rbHPBeforeUS), 2), " days and one downstream journey every ", round(as.numeric(totalDaysBefore)/nrow(rbHPBeforeDS), 2), " days.")

afterRBtoHPSequencesMessage <- paste0("Since the Connectivity Channel was built, there have been ", nrow(rbHPAfterUS), " upstream journeys from Red Barn Antenna to Hitching Post Antenna by non-Avian predated fish and ", nrow(rbHPAfterDS), " downstream journeys from Hitching Post Antenna to Red Barn over the course of ", round(totalDaysAfter, 2), " days. This equates to one  upstream journey every ", round(as.numeric(totalDaysAfter)/nrow(rbHPAfterUS), 2), " days and one  downstream journey every ", round(as.numeric(totalDaysBefore)/nrow(rbHPAfterDS), 2), " days on average.") 


```
#### `r totalBeforeSequenceMessage`
#### `r totalAfterSequenceMessage`

#### `r beforeRBtoHPSequencesMessage`
#### `r afterRBtoHPSequencesMessage`


## Avian Predation
Throughout the duration of the study, we have identified `r `
```{r echo=FALSE, include=TRUE}
# movement of fish vs avian predated/Known Merg

TimeFrame <- "Hours"
#TimeFrame <- "Days"
latLongCRS <- st_crs("+proj=longlat +datum=WGS84 +no_defs") #should be same as +init=epsg:4326
fraserColoradoRiverConfluence <- as.numeric(wgfpMetadata$ImportantStationingVariables[wgfpMetadata$ImportantStationingVariables$Variable == "Fraser/Colorado River Confluence", "StationingLocation"])

AllEvents <- combinedData_df_list$All_Events %>%
  filter(TAG == "230000294213", 
         Date >= as.Date("2025-10-05") & Date <= as.Date("2025-10-08")
    ) %>%
  mutate(hours_since = as.numeric(floor(difftime(Datetime, min(Datetime), units = "hours"))), 
         hourSequence = as_datetime(as.character(round(Datetime, units = "hours"))), 
         days_since = as.numeric(ceiling(difftime(Date, min(Date), units = "days"))),
         #makes sense to use floor not cieling with weeks because then there are are more fish in week 0
         # if you want to start at week 1 instead of week 0, add +1 to the end of expression
         # when you change this too, it changes the number of entries in the states dataframe
         weeks_since = as.numeric(floor(difftime(Date, min(Date), units = "weeks"))), 
         daySequence = as.Date(as.character(round(Datetime, units = "days")))
         )

if(TimeFrame == "Hours") {
  LastEvent <- AllEvents %>%
    group_by(TAG, hourSequence) %>%
    filter(Datetime == last(Datetime)) %>%
    ungroup()
} 

#get movements
LastEvent1 <- sf::st_as_sf(LastEvent, coords = c("UTM_X", "UTM_Y"), crs = 32613, remove = FALSE)
#convert to lat/long
EventsSFLatLong <- sf::st_transform(LastEvent1, latLongCRS)
#stattions needed to calculate movements and distance moved
stationsAndEvents <- sf::st_join(EventsSFLatLong, simpleStations, st_nearest_feature)


MovementsStationsFraserColoradoCorrected <- stationsAndEvents %>%
  left_join(wgfpMetadata$AntennaMetadata[,c("FrontendSiteCode", "River")], by = c("Event" = "FrontendSiteCode")) %>%
  #selects first non-NA value from set of columns; by having River.Y first it prioritizes that column
  mutate(River = coalesce(River.y, River.x), 
         # this part is needed because stations are assigned from 0 up the fraser river starting at the confluence
         #new antennas weren't showing up because I didn't include connectivity channel to to river
         # this assigns a station, then in the get_movements function the distance moved is calculated
         ET_STATION = case_when(River %in% "Fraser River" ~ ET_STATION + fraserColoradoRiverConfluence, #10120 is above Fraser River Confluence; pre-construciton was 9566
                                River %in% c("Colorado River", "Connectivity Channel") ~ ET_STATION,
                                TRUE ~ ET_STATION)
  ) %>%
  select(-River.x, -River.y)

allLastEventsWithMovements <- MovementsStationsFraserColoradoCorrected %>%
  group_by(TAG) %>%
  arrange(Datetime) %>%
  mutate(dist_moved = case_when(lag(ET_STATION, order_by = Datetime) > fraserColoradoRiverConfluence & ET_STATION > fraserColoradoRiverConfluence & River != lag(River, order_by = Datetime) ~ (lag(ET_STATION, order_by = Datetime) - fraserColoradoRiverConfluence) + (ET_STATION - fraserColoradoRiverConfluence),
                                TRUE ~ ET_STATION - lag(ET_STATION, order_by = Datetime)
                                ), 
                                
    movement_only = case_when(lag(ET_STATION, order_by = Datetime) > fraserColoradoRiverConfluence & ET_STATION > fraserColoradoRiverConfluence & River != lag(River, order_by = Datetime) ~ "Changed Rivers",
                            Event %in% c("Release", "Recapture and Release")  ~ "Initial Release",
                            dist_moved == 0 ~ "No Movement",
                            dist_moved > 0 ~ "Upstream Movement",
                            dist_moved < 0 ~ "Downstream Movement")
  )

coords1 <- st_as_sfc(st_bbox(c(xmin = -106.0771, xmax = -105.8938, ymax = 40.14896, ymin = 40.05358), crs = st_crs(4326)))

webMercatorAllEvents <- st_transform(allLastEventsWithMovements, crs = 3857)

webMercatorAllEvents <- webMercatorAllEvents %>%
  ungroup() %>%
  #rowid_to_column("rowNum") %>%
  mutate(#xx = row_number(),
    X.1 = st_coordinates(webMercatorAllEvents)[row_number(),1], 
         Y.1 = st_coordinates(webMercatorAllEvents)[row_number(),2] )

num_hours <- max(webMercatorAllEvents$hours_since) - min(webMercatorAllEvents$hours_since) + 1
num_days <- max(webMercatorAllEvents$days_since) - min(webMercatorAllEvents$days_since) + 1


basemaps::set_defaults(map_service = "esri", map_type = "world_imagery")
map_with_data <- ggplot() +
  basemap_gglayer(coords1) +
  scale_fill_identity() +
  coord_sf() +
  theme_classic() +
  guides(size = 'none', color = guide_legend(title = "Movement"))

map_with_data1 <- map_with_data + 
  #to get the data to show up, it needs to be a layer over the basemap
  #to associate the right type of movements wth the same tag, need to group by Tag for aesthetics
  # geom_point(data = webMercatorAllEvents, aes(x = webMercatorAllEvents$X.1, y = webMercatorAllEvents$Y.1, size = 10, 
  #                                             group = TAG)) +
  geom_sf(data = webMercatorAllEvents, aes(
    size = 10,
    color = movement_only,
    group = TAG)) +
  scale_color_manual(values = allColors) +
  theme(axis.title.x = element_blank(), axis.title.y = element_blank())

  frameUnit <- num_hours
  map_with_data1 <- map_with_data1 +
    transition_time(hourSequence) +
    enter_fade() +
    exit_shrink() +
    ggtitle(
      
      paste("Tagged Brown Trout (335mm):", '{frame_time}'), #{frame_time}
      subtitle = paste("Starting Date: ", min(webMercatorAllEvents$Date)))



#animate(map_with_data1, nframes = num_days + endPauseValue, end_pause = endPauseValue, fps = 10)
#map_with_data1
endPauseValue = 30
animate(map_with_data1, nframes = frameUnit + endPauseValue, end_pause = endPauseValue, fps = 5, height = 1200, width =1200) #, height = 1200, width =1200

############################### MERG


TimeFrame <- "Hours"
#TimeFrame <- "Days"
latLongCRS <- st_crs("+proj=longlat +datum=WGS84 +no_defs") #should be same as +init=epsg:4326
fraserColoradoRiverConfluence <- as.numeric(wgfpMetadata$ImportantStationingVariables[wgfpMetadata$ImportantStationingVariables$Variable == "Fraser/Colorado River Confluence", "StationingLocation"])

AllEvents <- combinedData_df_list$All_Events %>%
  filter(TAG == "230000087407", 
         Date >= as.Date("2024-09-17") & Date <= as.Date("2024-09-21")
    ) %>%
  mutate(hours_since = as.numeric(floor(difftime(Datetime, min(Datetime), units = "hours"))), 
         hourSequence = as_datetime(as.character(round(Datetime, units = "hours"))), 
         days_since = as.numeric(ceiling(difftime(Date, min(Date), units = "days"))),
         #makes sense to use floor not cieling with weeks because then there are are more fish in week 0
         # if you want to start at week 1 instead of week 0, add +1 to the end of expression
         # when you change this too, it changes the number of entries in the states dataframe
         weeks_since = as.numeric(floor(difftime(Date, min(Date), units = "weeks"))), 
         daySequence = as.Date(as.character(round(Datetime, units = "days")))
         )

if(TimeFrame == "Hours") {
  LastEvent <- AllEvents %>%
    group_by(TAG, hourSequence) %>%
    filter(Datetime == last(Datetime)) %>%
    ungroup()
} 

#get movements
LastEvent1 <- sf::st_as_sf(LastEvent, coords = c("UTM_X", "UTM_Y"), crs = 32613, remove = FALSE)
#convert to lat/long
EventsSFLatLong <- sf::st_transform(LastEvent1, latLongCRS)
#stattions needed to calculate movements and distance moved
stationsAndEvents <- sf::st_join(EventsSFLatLong, simpleStations, st_nearest_feature)


MovementsStationsFraserColoradoCorrected <- stationsAndEvents %>%
  left_join(wgfpMetadata$AntennaMetadata[,c("FrontendSiteCode", "River")], by = c("Event" = "FrontendSiteCode")) %>%
  #selects first non-NA value from set of columns; by having River.Y first it prioritizes that column
  mutate(River = coalesce(River.y, River.x), 
         # this part is needed because stations are assigned from 0 up the fraser river starting at the confluence
         #new antennas weren't showing up because I didn't include connectivity channel to to river
         # this assigns a station, then in the get_movements function the distance moved is calculated
         ET_STATION = case_when(River %in% "Fraser River" ~ ET_STATION + fraserColoradoRiverConfluence, #10120 is above Fraser River Confluence; pre-construciton was 9566
                                River %in% c("Colorado River", "Connectivity Channel") ~ ET_STATION,
                                TRUE ~ ET_STATION)
  ) %>%
  select(-River.x, -River.y)

allLastEventsWithMovements <- MovementsStationsFraserColoradoCorrected %>%
  group_by(TAG) %>%
  arrange(Datetime) %>%
  mutate(dist_moved = case_when(lag(ET_STATION, order_by = Datetime) > fraserColoradoRiverConfluence & ET_STATION > fraserColoradoRiverConfluence & River != lag(River, order_by = Datetime) ~ (lag(ET_STATION, order_by = Datetime) - fraserColoradoRiverConfluence) + (ET_STATION - fraserColoradoRiverConfluence),
                                TRUE ~ ET_STATION - lag(ET_STATION, order_by = Datetime)
                                ), 
                                
    movement_only = case_when(lag(ET_STATION, order_by = Datetime) > fraserColoradoRiverConfluence & ET_STATION > fraserColoradoRiverConfluence & River != lag(River, order_by = Datetime) ~ "Changed Rivers",
                            Event %in% c("Release", "Recapture and Release")  ~ "Initial Release",
                            dist_moved == 0 ~ "No Movement",
                            dist_moved > 0 ~ "Upstream Movement",
                            dist_moved < 0 ~ "Downstream Movement")
  )

coords1 <- st_as_sfc(st_bbox(c(xmin = -106.0771, xmax = -105.8938, ymax = 40.14896, ymin = 40.05358), crs = st_crs(4326)))

webMercatorAllEvents <- st_transform(allLastEventsWithMovements, crs = 3857)

webMercatorAllEvents <- webMercatorAllEvents %>%
  ungroup() %>%
  #rowid_to_column("rowNum") %>%
  mutate(#xx = row_number(),
    X.1 = st_coordinates(webMercatorAllEvents)[row_number(),1], 
         Y.1 = st_coordinates(webMercatorAllEvents)[row_number(),2] )

num_hours <- max(webMercatorAllEvents$hours_since) - min(webMercatorAllEvents$hours_since) + 1
num_days <- max(webMercatorAllEvents$days_since) - min(webMercatorAllEvents$days_since) + 1


basemaps::set_defaults(map_service = "esri", map_type = "world_imagery")
map_with_data <- ggplot() +
  basemap_gglayer(coords1) +
  scale_fill_identity() +
  coord_sf() +
  theme_classic() +
  guides(size = 'none', color = guide_legend(title = "Movement"))

map_with_data1 <- map_with_data + 
  #to get the data to show up, it needs to be a layer over the basemap
  #to associate the right type of movements wth the same tag, need to group by Tag for aesthetics
  # geom_point(data = webMercatorAllEvents, aes(x = webMercatorAllEvents$X.1, y = webMercatorAllEvents$Y.1, size = 10, 
  #                                             group = TAG)) +
  geom_sf(data = webMercatorAllEvents, aes(
    size = 10,
    color = movement_only,
    group = TAG)) +
  scale_color_manual(values = allColors) +
  theme(axis.title.x = element_blank(), axis.title.y = element_blank())

  frameUnit <- num_hours
  map_with_data1 <- map_with_data1 +
    transition_time(hourSequence) +
    enter_fade() +
    exit_shrink() +
    ggtitle(
      
      paste("Tagged Merganser Fledgling:", '{frame_time}'), #{frame_time}
      subtitle = paste("Starting Date: ", min(webMercatorAllEvents$Date)))



#animate(map_with_data1, nframes = num_days + endPauseValue, end_pause = endPauseValue, fps = 10)
#map_with_data1
endPauseValue = 30
animate(map_with_data1, nframes = frameUnit + endPauseValue, end_pause = endPauseValue, fps = 5, height = 1200, width =1200) #, height = 1200, width =1200




```

